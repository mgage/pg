DOCUMENT();  
loadMacros(
"PGstandard.pl",
"MathObjects.pl",
"parserPopUp.pl",
"unionLists.pl",
"MatrixReduce.pl",
#"AppletObjects.pl",
"PGessaymacros.pl",
"PGmatrixmacros.pl",
"LinearProgramming.pl",
"parserLinearInequality.pl",
"quickMatrixEntry.pl",
#"scaffold.pl",
"tableau.pl",
"tableau_main_subroutines.pl",
#"gage_matrix_ops.pl",
"PGinfo.pl",
"source.pl",
"PGcourse.pl",
);

TEXT(beginproblem());
TEXT($BEGIN_ONE_COLUMN);
$showPartialCorrectAnswers = 1;

INITIALIZE_QUICK_MATRIX_ENTRY();


##############################################################
# problem data
##############################################################

# this can be changed (slightly at least) without affecting the behavior of the problem
# The choice of pivots is not yet automatic However

# Your resources:
$money_total = 6000;
$time_total  = 600;

# Bill
$bill_money_commitment = 5000; #dollars
$bill_time_commitment  = 400;  # hours
$bill_profit = 4700;
# Steve
$steve_money_commitment = 3000;
$steve_time_commitment  = 500;
$steve_profit = 4500;

#Hack to prevent domain conflict in answer.
Context()->variables->add(p1=>'Real',p2=>'Real');
$objfun1 = Formula("${bill_profit}p1 + ${steve_profit}p2");
# why can't the formula be defined within context "linearInequality"?

Context("LinearInequality");
Context()->variables->add(p1=>'Real',p2=>'Real');
Context()->strings->add("Essay Answer" =>{});
Context()->strings->add('Minimize'=>{},'Maximize'=>{}, "?"=>{});
Context()->strings->add('Yes'=>{},'No'=>{});
Context()->flags->set({tolType=>"absolute",tolerance=>.001});
Context()->flags->set(
	zeroLevel=>0.001,
	zeroLevelTol=>.001
);
# $objfun1 = Formula("${bill_profit}p1 + ${steve_profit}p2");

our $context=Context();

##############################################################
#
#  Setup
#
#



##############################################################################
# utility subroutine for checking your answers
##############################################################################

sub update_tableau {
	my $original_matrix = shift;
	my $basis           = shift;
	# $basis is a Set object
	# last row is numbered $basis_size+1;
	my $basis_size=@{$basis->data};
	my $basis_matrix = $original_matrix->submatrix(rows=>[1..$basis_size],columns=>$basis->data);

	my $obj_coeff = - ($original_matrix->row($basis_size+1));
	#obj function coeff corresponding to basis variables/columns
	$cB = Matrix($obj_coeff->column_slice($basis->data));
	# get A | S |b portion of tableau and multiply by det(B)B^-1
	my $current_matrix= ($basis_matrix->det)*
	        ($basis_matrix->inverse)*
	        $original_matrix->row_slice(1..$basis_size);
	my $new_obj_row = ($cB*$current_matrix)->row(1) - ($basis_matrix->det)*($obj_coeff);
	my $current_tableau = Matrix(@{$current_matrix->extract_rows},Matrix($new_obj_row));
	return $current_tableau;
}
# the full tableau has one more row -- the objective function
sub display_tableau_state {
	my ($original_matrix,$tableau, $matrix, $basis,$pivot)= @_;
	$basis = $basis->sort;
	my $basis_size = @{$basis->data} ;
	my $basis_matrix = matrix_from_submatrix($original_matrix, rows=>[1..$basis_size],columns=>$basis->data);
	my $normalized_tableau = $matrix;
	my $reduced_matrix = matrix_from_matrix_rows($matrix,1..$basis_size);
	warn "basis matrix is $basis_matrix, $reduced_matrix";
	my $normalized_reduced_matrix = ($basis_matrix->det)*$reduced_matrix;
	# calculate current tableau by multiplying by the inverse of the basis
	my $obj_coeff = - $original_matrix->row($basis_size+1);
	my $cB = Matrix($obj_coeff->column_slice($basis->data));
	my $current_matrix = ($basis_matrix->det)*($basis_matrix->inverse)*matrix_from_matrix_rows($original_matrix,1..$basis_size);
	my $new_obj_row = ($cB*$current_matrix)->row(1) - ($basis_matrix->det)*($obj_coeff);
	my $current_tableau = Matrix(@{$current_matrix->extract_rows},Matrix($new_obj_row));
	$current_tableau = update_tableau($original_matrix, $basis);
	
	#DEBUG_MESSAGE("get state variables for $matrix using basis $basis");
	@statevars1 = get_tableau_variable_values($matrix, $basis);
	# get z value
	$statevars1 = ~~@statevars1;
	$state = Matrix([[@statevars1]]);


	return "
	<font size='-2'>
	pivot: \($pivot\) basis: \( $basis\) $PAR  basis matrix \(".
	display_matrix_mm($basis_matrix)."\) $PAR
	tableau and normalized current tableau   $PAR
	 \(" . lp_display_mm($tableau) . "\)\(".lp_display_mm($normalized_tableau). " \) $PAR 
	original matrix and current matrix calculated by Binverse*original $PAR
	\(".
	display_matrix_mm(matrix_from_matrix_rows($original_matrix,1..$basis_size)).
	"\)  \(".
	display_matrix_mm($current_matrix).
	"\)  $PAR
	objective coefficients = \( $obj_coeff \) $PAR
	basis objective_coefficients = \($cB\) $PAR
	new tableau \[".
	lp_display_mm($current_tableau).
	"\]  $PAR
	state:  \($state)\)  $PAR
	</font>"
}


# #########################################################################################################
# # Section 4 dual problem
# #########################################################################################################


Context()->variables->add(y1=>'Real',y2=>'Real', y3=>'Real', y4=>'Real', w=>'Real',y0=>'Real');
$dual_constraint1 = Compute("${bill_money_commitment}y1 +${bill_time_commitment}y2 +y3 >=$bill_profit");
$dual_constraint2 = Compute("${steve_money_commitment}y1 +${steve_time_commitment}y2 +y4 >=$steve_profit");
$dual_constraints= List($dual_constraint1, $dual_constraint2);

$dual_objfun = Formula("${money_total}y1 +${time_total}y2 + y3 +y4");
$popupmaxmin = PopUp(["?","Maximize", "Minimize"], "Minimize");

Context()->texStrings;

BEGIN_TEXT
Construct the dual problem for the linear optimization problem above.  The first goal is to calculate
an upper bound for the possible profit in the LOP using linear combinations of the inequality constraints.
Then formulate the search for the best of these upper bounds in such a way that it 
becomes a new LOP -- the dual problem.  Use variables \(y_1,y_2,y_3,y_4\) to create linear combinations
of the constraints on money, time and the total probabilities \(p_1\) and \(p_2\) respectively,
and create a linear function \(w = Ay_1 + By_2 +Cy_3 +Dy_4\) which guarantees that \(w\) will
be larger than any profit one could make. What constraints must \(y_1\dots y_4\) satisfy?
$PAR
\{ANS($dual_constraints->cmp->withPostFilter(
	linebreak_at_commas()
)),ans_box(4,80)\}
$PAR The objective function would be:
 \(w = \) \{ANS($dual_objfun->cmp), $dual_objfun->ans_rule(50)\}
$PAR
To get the best possible estimate for the profit in the original problem 
you would want to \{ANS($popupmaxmin->cmp),$popupmaxmin->menu\} \(w\)
Why?
$PAR
\{ANS(essay_cmp()), essay_box(5,80)\}
END_TEXT

BEGIN_SOLUTION
The profit is less than the minimum of \( w = $dual_objfun \) subject to

\[\begin{aligned}
$dual_constraint1 & \\
$dual_constraint2 & 
\end{aligned}
\]
The \(y_i\) are the coefficients used to add up the constraint inequalities of the primary problem
so as to estimate an upper bound for the profit. If the \(y_i\) are positive values satisfying
the constraints then \(w\) will be greater than or equal to the profit.  We get the most precise
estimate by finding values of \(y_i\), satisfying the constraints, which give the smallest 
possible value for \( w\).

END_SOLUTION
Context()->normalStrings;


# #########################################################################################################
# # Section 5 set up dual constraints
# #########################################################################################################

Context($context);
$dualtableau1 = [[-$bill_money_commitment,-$bill_time_commitment, -1, 0,  1, 0, 0,-$bill_profit], 
                 [-$steve_money_commitment, -$steve_time_commitment,0,-1, 0, 1, 0,-$steve_profit],
                 [${money_total},${time_total},1, 1, 0,0, 1,0]];
$dualmatrix1 = Matrix($dualtableau1);
$dualtoplabels = [qw(y1 y2 y3 y4 y5 y6 v b)];
$dualmatrix1->{top_labels}=$dualtoplabels;
$dualtableau1_string =  lp_display_mm($dualtableau1,top_labels=>$dualtoplabels);

$popup = PopUp(["?","Yes", "No"], "No");

$dual_row_size =2;  # figure these out automatically
$dual_col_size =$col_size; 
BEGIN_TEXT
dualmatrix1 size \{join(",", $dualmatrix1->dimensions)\} $BR
$dual_row_size,  $dual_col_size
END_TEXT
Context()->texStrings;

BEGIN_TEXT
$PAR
For this first effort let's rewrite the equations so that they are in "standard" form, meaning
that the inequalities are all less than or equal to and that the goal is to maximize \(v = -w\).
This will probably mean that you will have to rewrite the natural way in which you set up 
the problem above.  Some coefficients will change sign. 
We will still be using the convention that 
the coefficient of \(v\) will be \(1\).

$PAR
\{MATRIX_ENTRY_BUTTON($dualmatrix1)\}
\{ANS($dualmatrix1->cmp()), $dualmatrix1->ans_array \}
$PAR
(This tableau is for maximizing \(v\), aka \(-w\) -- there are two minus sign switches. )
$PAR 
Is there a natural feasible solution to this problem? In other words does setting the 
problem parameters equal to 0 provide a feasible solution?
\{ANS($popup->cmp),$popup->menu \} 
$PAR
Explain why or why not and what are your options for getting started.
\{ ANS(essay_cmp()), essay_box(10,80) \}
$PAR
END_TEXT

BEGIN_SOLUTION
\[  $dualtableau1_string  \]
$PAR
Setting the parameters \(y_1, y_2\) to zero is not a feasible solution. 
Options for finding a first feasible solution include guessing (not a bad choice
for a problem this small), using prior knowledge (e.g. a known optimal solution to
a similar problem), creating an auxiliary problem to find a feasible point,
and the "shortcut method" which is an accelerated version of the "auxiliary method". 
END_SOLUTION


# #########################################################################################################
# # Begin section 6 -- solve the tableau using  simplex method
# # section 6 (13matrix, 14essay)
# # First we have to find a feasible solution -- phase 1
# # We'll use the auxiliary method -- adding an extra slack variable.
# #########################################################################################################


Context($context);
$dualtableau2aux = [[-1,-$bill_money_commitment,-$bill_time_commitment, -1, 0, 	1,0,0,0,-$bill_profit], 
                 [-1,-$steve_money_commitment,-$steve_time_commitment, 0, -1, 0,1,0,0,-$steve_profit],
                 [1,0,0,0,0,0,0,0,1,0]];

#                [0,$money_total,$time_total,1,1,0,0,1,0,0]];
$dualmatrix2aux = Matrix($dualtableau2aux);
$original_dual_aux_matrix=$dualmatrix2aux;
$dualtoplabelsphase1 = [qw(y0 y1 y2 y3 y4 y5 y6 v z b)];
$dualmatrix2aux->{top_labels}= $dualtoplabelsphase1;
$dual_constraint1phase1 = Compute("-${bill_money_commitment}y1 -${bill_time_commitment}y2 -y3 <=-$bill_profit+y0");
$dual_constraint2phase1 = Compute("-${steve_money_commitment}y1 -${steve_time_commitment}y2 -y4 <=-$steve_profit+y0");
$dualconstraintsphase1 = List($dual_constraint1phase1,$dual_constraint2phase1);
$dualpivot2aux=Point(1,1);
$dualbasis2aux=Set(6,7);
#########################################################################################################
# section 6 answers (15essay 16matrix)
#########################################################################################################
Context()->texStrings;

BEGIN_TEXT
Using the auxiliary method write the LOP for finding 
the first feasible point.  Write  
the new constraints to be used by auxiliary method. $PAR
\{  ANS($dualconstraintsphase1->cmp),ans_box(3,80) \}
$PAR
We will continue to use the convention that we are maximizing
the auxiliary function so there will be some minus signs that need to be taken into account.
We'll let \(z = -y_0\) and try to maximize \(z\). 
$PAR
Now construct the tableau you'll use for the auxiliary method. 
Add a first column for the extra slack variable and a next to the last row 
for the new objective function value \(z\) and write the new tableau. 
The next to the last row will hold the objective function for \(z\). 
The last row will hold the original
dual objective function which we'll just carry along.
$PAR
\{MATRIX_ENTRY_BUTTON($dualmatrix2)\}
\{ANS($dualmatrix2aux->cmp()), $dualmatrix2aux->ans_array \}
$PAR
END_TEXT
#########################################################################################################
# debugging display code
#########################################################################################################
BEGIN_TEXT

Display dualtableau2aux
\($dualtableau2aux\), matrix \($dualmatrix2aux\) 
dualbasis \($dualbasis2aux\) and \($dualpivot2aux\)
$PAR
\{display_tableau_state($original_dual_aux_matrix,$dualtableau2aux, $dualmatrix2aux,  $dualbasis2aux,  $dualpivot2aux)\} 
$PAR
END_TEXT

Context()->normalStrings;

Context()->texStrings;
BEGIN_SOLUTION
New objective: Maximize \(z = -y_0 \) subject to 
\[\begin{align}
$dual_constraint1phase1&\\
$dual_constraint2phase1 &\\
\end{align}
\] with all variables non-negative.
$PAR
If \(y_0\) is large enough this always has a feasible solution with  
\(y_1=y_2=0\).

\[  \{lp_display_mm($dualtableau2aux) \}  \]
$PAR
END_SOLUTION
Context()->normalStrings;



# #########################################################################################################
# # Section 7  final comparisons of primary and dual results.
# #########################################################################################################
 $dualpivot3aux=$dualpivot2aux=Point(1,1);  #already set
 ($dualtableau3aux,$dualbasis3aux, $dualstatevars3aux) = lp_basis_pivot($dualtableau2aux,$dualbasis2aux,$dualpivot2aux);
 $B3 = matrix_from_submatrix($original_dual_aux_matrix,rows=>[1..$dual_row_size],columns=>($dualbasis3aux->data));
 $dualmatrix3aux = ($B3->det)*Matrix($dualtableau3aux);
 $dualmatrix3aux->{top_labels}=$dualtoplabelsphase1;
 $dualstate3aux=Matrix([[@$dualstatevars3aux]]);
 

# $dualpivot4aux = Point("(1,1)");
# $dualtableau3aux = lp_pivot($dualtableau2,0,0);
# $dualmatrix3 = Matrix($dualtableau3aux);
# $dualmatrix3->{top_labels}=$dualtoplabelsphase1;
# $dualtableau3_string =  lp_display_mm($dualtableau3aux);
# $z_initial=-$bill_profit;  # a hint
# # this is the initial value of the z=-y0 variable we are maximizing?

# now start to maximize z
$dualpivot4aux = Point("(2,2)");
$dualtableau4aux = lp_pivot($dualtableau3aux,1,1);
$denom1 = 2000;
$dualmatrix4aux = $denom1*Matrix($dualtableau4aux);
$dualmatrix4aux->{top_labels}=$dualtoplabelsphase1;
$dualtableau4aux_string =  lp_display_mm($dualmatrix4aux);

$dualpivot5aux= Point("(1,3)");
$dualtableau5aux = lp_pivot($dualtableau4aux,0,2);

## FIXME entries close to zero in a matrix are not being compared properly. 
## FIXME tolerance and tolType are being ignored

#$dualtableau5->[2][3]=0;
#$dualtableau5->[2][5]=0;

$denom2 = 1.3E6;
$dualmatrix5aux = $denom2*Matrix($dualtableau5aux);
$dualmatrix5aux->{top_labels}=$dualtoplabelsphase1;
$dualtableau5_string =  lp_display_mm($dualmatrix5aux);
$state5 = Matrix([[ 	0.423,	6.4615,		0,		0,		-6415.38]]);
$popup5 = PopUp(["?","Yes", "No"], "No");

$dualpivot5aux= Point("(1,3)");
$dualtableau5aux = lp_pivot($dualtableau4aux,0,2);

## FIXME entries close to zero in a matrix are not being compared properly. 
## FIXME tolerance and tolType are being ignored

#$dualtableau5->[2][3]=0;
#$dualtableau5->[2][5]=0;

$denom2 = 1.3E6;
$dualmatrix5aux = $denom2*Matrix($dualtableau5aux);
$dualmatrix5aux->{top_labels}=$dualtoplabelsphase1;
$dualtableau5_string =  lp_display_mm($dualmatrix5aux);

#########################################################################################################
# debugging display code
#########################################################################################################
BEGIN_TEXT
$PAR
(1,1) Debugging display code dualtableau3aux.  This is the matrix 
after pivoting on (1,1) \($dualpivot3aux\) to basis $dualbasis3aux . 
newbasis: \{$newdualbasis3aux=Set(1,7)\} $newdualbasis3aux
$PAR

\{display_tableau_state($original_dual_aux_matrix,
						$dualtableau3aux, $dualmatrix3aux,  
						$newdualbasis3aux,   $dualpivot3aux)\} 
$PAR

(2,2) Debugging display code dualtableau4aux.
This is the matrix after pivoting on $dualpivot4aux and basis $dualbasis3aux 
and basis $dualbasis3aux . 
newbasis: \{$newdualbasis4aux=Set(1,2)\} $newdualbasis4aux
$PAR
\{display_tableau_state($original_dual_aux_matrix,
						$dualtableau4aux, $dualmatrix4aux,  
						$newdualbasis4aux,   $dualpivot4aux)\} 
$PAR

(1,3) Debugging display code dualtableau5aux.
This is the matrix after pivoting on $dualpivot5aux and basis $dualbasis3aux . 
newbasis: \{$newdualbasis5aux=Set(2,3)\}
$PAR
\{display_tableau_state($original_dual_aux_matrix,
						$dualtableau5aux, $dualmatrix5aux,  
						$newdualbasis5aux,   $dualpivot5aux)\} 
$PAR
END_TEXT
# #########################################################################################################
# # Section 7 answers 17,18matrix,19,20matrix,21,22matrix,23, 24,25essay
# #########################################################################################################



Context()->texStrings;

BEGIN_TEXT
The first pivot, which will make the right hand side entries positive is 
\{ANS($dualpivot3aux->cmp),$dualpivot3aux->ans_rule \}. $PAR
Recall that in the case of tie we take entry with the least index
(i.e. left most or upper most. )
$PAR


The resulting tableau is  $PAR
\{MATRIX_ENTRY_BUTTON($dualmatrix3aux)\}
\{ANS($dualmatrix3aux->cmp), $dualmatrix3aux->ans_array() \}

The value of \(z=-y_0\) is \($z_initial\). 
$PAR
The next pivot, following the simplex method to maximize \(z\), is
\{ANS($dualpivot4aux->cmp), $dualpivot4aux->ans_rule\}. 
$PAR 
(Many of the following answers have lots of zeros.  You can use the shortcut
1E3 to stand for \(1\times 10^3\). )
$PAR
Notice that because of the zero on the right hand side none of the state variables change.  We had three
hyperplanes intersecting at a point and we have changed our mind about which
of those three we consider basic. The new tableau is 
$PAR
\{MATRIX_ENTRY_BUTTON($dualmatrix4aux)\}
\{ANS($dualmatrix4aux->cmp), $dualmatrix4aux->ans_array() \}
$PAR
The next pivot \{ ANS($dualpivot5aux->cmp), $dualpivot5aux->ans_rule \} leads to $PAR
\{MATRIX_ENTRY_BUTTON($dualmatrix5aux)\}
\{#FIXME -- these tolerance leveals are being ignored \}
\{ANS($dualmatrix5aux->cmp()), $dualmatrix5aux->ans_array() \}

$PAR and we notice that now \(z=-y_0=0\) so we have found a basic feasible solution to our 
original dual problem.  The variables \(y_1,y_2,y_3,y_4,v\) for this 
solution are 
$PAR

\{ANS($state5->cmp),$state5->ans_array\}
$PAR
Do we need to continue to optimize the value for \(v\)?
\{ANS($popup5->cmp), $popup5->menu()\}  Why? $PAR
\{ANS(essay_cmp), essay_box(3,80)\}
$PAR
Compare this answer \(v^*= -w^*\) to the dual problem to the optimal value \(P^*\)for the primary problem.
The problems' goals were to maximize \(P\) and to minimize \(w\). 
$PAR

END_TEXT

BEGIN_SOLUTION
The first pivot is \($dualpivot3aux\) which makes the right hand side entries positive. 
$PAR
\[$dualtableau3_string\]
$PAR
The next pivot is \($dualpivot4aux\).  It follows the simplex rule of choosing the row
with the most restrictive ratio -- in this case zero.  The result is simply to
choose a new representation of the same point -- no change in state takes place.
$PAR\[$dualtableau4_string\]
$PAR
The final pivot (as it turns out) is \($dualpivot5aux\). At this point we are done with
phase 1 because the value of \(z=-y_0=0\) so we have maximized \(z\) and 
minimized \(y_0\) to \(0\)
$PAR\[$dualtableau5_string\]
$PAR
At this point we notice that the coefficients in the last row are such that
we cannot increase the value of \(v\) any further. \(v\) is at its maximum
and \(w=-v\) is at its minimum.  The minimum value of \(w=64?\) which is the 
same as the maximum profit that we found in the first example.
END_SOLUTION
TEXT($END_ONE_COLUMN);
ENDDOCUMENT();

