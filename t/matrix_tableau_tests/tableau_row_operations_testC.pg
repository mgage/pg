##DESCRIPTION



##ENDDESCRIPTION


DOCUMENT();        # This should be the first executable line in the problem.

loadMacros(
   "PGstandard.pl",     # Standard macros for PG language
   "MathObjects.pl",
	"MatrixReduce.pl",
	#"AppletObjects.pl",
	"PGessaymacros.pl",
	"PGmatrixmacros.pl",
	"PGML.pl",
	"LinearProgramming.pl",
	"parserLinearInequality.pl",
	"quickMatrixEntry.pl",
	#"scaffold.pl",
	"tableau.pl",
	#"gage_matrix_ops.pl",
	"PGinfo.pl",
	"source.pl",
	"PGcourse.pl",
);

TEXT(beginproblem());
$showPartialCorrectAnswers = 1;

##############################################################
#
#  Setup
#
#
Context("Matrix");

Context()->flags->set(
	zeroLevel=>0.001,
	zeroLevelTol=>.001
);
INITIALIZE_QUICK_MATRIX_ENTRY();

$money_total = 6000;
$time_total  = 600;

# Bill
$bill_money_commitment = 5000; #dollars
$bill_time_commitment  = 400;  # hours
$bill_profit = 4700;
# Steve
$steve_money_commitment = 3000;
$steve_time_commitment  = 500;
$steve_profit = 4500;


#constraint matrix
$A = Matrix([[-1,-$bill_money_commitment,-$bill_time_commitment, -1, 0],
             [ -1,-$steve_money_commitment,-$steve_time_commitment, 0, -1, ]]);
$b = Matrix([[-$bill_profit,-$steve_profit]])->transpose;
$c = Matrix([1,0,0,0,0]);

$tableau1 = Tableau->new(A=>$A, b=>$b,  c=>$c);
$m = $tableau1->{M};
$m2 = $tableau1->{current_constraint_matrix};
$tableau_orig = $tableau1->current_tableau;
$basis_orig = $tableau1->basis;
#HR
$tableau1->basis(1,2);
$m3 = $tableau1->{M};
$m4 = $tableau1->{current_constraint_matrix};
$tableau_orig3 = $tableau1->current_tableau;
$basis_orig3 = $tableau1->basis;
#HR
$tableau1->basis(6,7);
$t1 = $tableau1->current_tableau;
($index1, $value1, $feasible1) = $tableau1->find_short_cut_row();
($index2, $value2, $infeasible2) = $tableau1->find_short_cut_column(1); 
# search row 1
($index3, $value3) = $tableau1->find_leaving_column(1);
$basis17 = $tableau1->find_next_basis_from_pivot(1,1);
$basis17=Set($basis17)->sort ;

$tableau1->basis($basis17->value);  # basis should be able to accept Set and List objects
$basis17check = $tableau1->basis;
$tableau17= $tableau1->current_tableau;
$matrix17 = $tableau1->{current_constraint_matrix}; #  M = A | S |b
#HR last part of phase 1
($index11, $value11, $feasible11) = $tableau1->find_short_cut_row();

#HR first pivot of phase2
($pivot1col, $value1c, $optimum1a) = $tableau1->find_pivot_column('min');
($pivot1row, $value1r, $unbounded1a) = $tableau1->find_pivot_row(2);
#($row2,$col2,$optimum2,$unbounded2)   = $tableau1->find_next_pivot('min');
#$basis2 = $tableau1->find_next_basis_from_pivot($row2, $col2);
#TEXT("basis2 has type ".ref($basis2));
#$tableau1->basis($basis2->value);
#$tableaudisplay1 = $tableau1->current_tableau;

#HR second pivot of phase2
#($pivot3col, $value3c, $optimum3a) = $tableau1->find_pivot_column('min');
#($pivot3row, $value3r, $unbounded3a) = $tableau1->find_pivot_row(3);
#($row3,$col3,$optimum3,$unbounded3) = $tableau1->find_next_pivot('min');
#$basis3 = $tableau1->find_next_basis_from_pivot($row3, $col3);
#$tableau1->basis($basis3->value);
#$tableaudisplay2 = $tableau1->current_tableau;

#HR third pivot of phase2
#($pivot4col, $value4c, $optimum4a) = $tableau1->find_pivot_column('min');
#($pivot4row, $value4r, $unbounded4a) = $tableau1->find_pivot_row(3);
#($row4,$col4,$optimum4,$unbounded4) = $tableau1->find_next_pivot('min');
#optimum is reached so can't go forward from here
#$basis4 = $tableau1->find_next_basis_from_pivot($row4, $col4);
#$tableau1->basis($basis4->value);
#$tableaudisplay3 = $tableau1->current_tableau;

### experimental
# basis calculation
TEXT(" start with basis (6,7) and pivot on (1,1)");
	$basis = Set(6,7);
 	$basis = $basis - Set(6);
 	$basis = List( 1, $basis->value,  );
TEXT( "new basis is $basis");

##############################################################
#
#  Text
#
#

Context()->texStrings;
BEGIN_TEXT
matrix: \[ $m  \quad $m2 \] $PAR
tableau: \[ $tableau_orig \] $PAR
original basis: $basis_orig $PAR
$HR
 
\[\{ $tableau1->current_tableau\}\]
basis \{$tableau1->basis()\} ,\{List($tableau1->{basis})\} $PAR
basis matrix \[\{$tableau1->{M}->
    submatrix(rows=>[1..($tableau1->{m})],columns=>$tableau1->{basis})\}\];
$PAR
new basis (2,3) 
\[\{$tableau1->current_tableau(2,3)\}\]
basis \{$tableau1->basis()\},  \{join(",",@{$tableau1->{basis}})\}$PAR
basis matrix \[\{$tableau1->{M}->submatrix(rows=>[1..($tableau1->{m})],columns=>$tableau1->{basis})\}\];
$PAR
new basis (3,2) 
\[\{$tableau1->current_tableau(3,2)\}\]
basis \{$tableau1->basis()\},  \{join(",",@{$tableau1->{basis}})\}$PAR
basis matrix \[\{$tableau1->{M}->submatrix(rows=>[1..($tableau1->{m})],columns=>$tableau1->{basis})\}\];
Should figure out why these don't reverse although internally they do.
$HR
submatrix (1,2) by (1,2)
\[\{$tableau1->{M}->submatrix(rows=>[1,2],columns=>[1,2])\}\];
\[\[\{$tableau1->{B}\}\];
submatrix (1,2) by (2,1)

\[\{$tableau1->{M}->submatrix(rows=>[1,2],columns=>[2,1])\}\];
\[\[\{$tableau1->{B}\}\];
$HR
Figure out outputs: $PAR
\[\{$tableau1->current_tableau(1,7) \} \]$PAR
test0 ( \(\{join(" |", $tableau1->find_next_basis('min'))\}\) )$PAR
test1 ( \{join(" |", @{ List($tableau1->find_next_basis('min'))->data} )\} )$PAR
test2 ( \{ [$tableau1->find_next_basis('min')]->[0]->value \},
\{ [$tableau1->find_next_basis('min')]->[1]->value \} )$PAR

find next pivot column ( \{ List( $tableau1->find_pivot_column('min')) \} )
----(\{ join ",", map {ref($_)} ( $tableau1->find_pivot_column('min')) \})
$PAR
find next pivot row for col 2:  ( \{ List($tableau1->find_pivot_row(2)) \} )
----(\{ join ",", map {ref($_)} ( $tableau1->find_pivot_row(2)) \})
$PAR
next pivot   \( ( \{ List( $tableau1->find_next_pivot('min')) \} )\)
----(\{ join ",", map {ref($_)} ( $tableau1->find_next_pivot('min')) \})
$PAR
next basis   \( ( \{ List( $tableau1->find_next_basis('min')) \} ) \)
----(\{ join ",", map {ref($_)} ( $tableau1->find_next_basis('min')) \})
$PAR
test pivot \( ( \{ List($tableau1->find_next_pivot('min')) \} ) \)
$PAR
END_TEXT

Context()->normalStrings;

ENDDOCUMENT();

